"""
SISTEMA DE LISTAS OPTIMIZADO
Implementa 4 tipos de listas con diccionarios como nodos
"""

class Nodo:
    """Nodo base para todas las listas"""
    def __init__(self, valor):
        if not 1 <= valor <= 98:
            raise ValueError("Valor debe estar entre 1 y 98")
        self.valor = valor
        self.siguiente = None
        self.anterior = None
    
    def __str__(self):
        return f"[{self.valor}]"

class Lista:
    """Clase principal que maneja todos los tipos de listas"""
    
    tipos = {
        1: ("enlazada", False, False),
        2: ("enlazada_d", True, False),
        3: ("circular", False, True),
        4: ("circular_d", True, True)
    }
    
    def __init__(self, tipo_id):
        self.tipo, self.doble, self.circular = self.tipos[tipo_id]
        self.cabeza = None
        self.cola = None
        self.tamano = 0
    
    # ========== OPERACIONES BÁSICAS ==========
    
    def crear_nodo(self, valor):
        """Crea un nuevo nodo"""
        return Nodo(valor)
    
    def insertar_inicio(self, valor):
        """Inserta nodo al inicio"""
        nuevo = self.crear_nodo(valor)
        
        if self.esta_vacia():
            self.cabeza = self.cola = nuevo
            if self.circular:
                nuevo.siguiente = nuevo
                if self.doble:
                    nuevo.anterior = nuevo
        else:
            nuevo.siguiente = self.cabeza
            if self.doble:
                self.cabeza.anterior = nuevo
                if self.circular:
                    nuevo.anterior = self.cola
                    self.cola.siguiente = nuevo
            self.cabeza = nuevo
        
        self.tamano += 1
        return True
    
    def insertar_final(self, valor):
        """Inserta nodo al final"""
        if self.esta_vacia():
            return False
        
        nuevo = self.crear_nodo(valor)
        
        if self.doble:
            nuevo.anterior = self.cola
        
        self.cola.siguiente = nuevo
        self.cola = nuevo
        
        if self.circular:
            nuevo.siguiente = self.cabeza
            if self.doble:
                self.cabeza.anterior = nuevo
        
        self.tamano += 1
        return True
    
    def insertar_nodo(self, valor, pos):
        """Inserta nodo en posición específica"""
        if pos < 0 or pos > self.tamano:
            return False
        
        if pos == 0:
            return self.insertar_inicio(valor)
        if pos == self.tamano:
            return self.insertar_final(valor)
        
        nuevo = self.crear_nodo(valor)
        actual = self.cabeza
        
        for _ in range(pos - 1):
            actual = actual.siguiente
        
        nuevo.siguiente = actual.siguiente
        actual.siguiente = nuevo
        
        if self.doble:
            nuevo.anterior = actual
            if nuevo.siguiente:
                nuevo.siguiente.anterior = nuevo
        
        self.tamano += 1
        return True
    
    def eliminar_nodo(self, valor):
        """Elimina nodo por valor"""
        actual = self.cabeza
        anterior = None
        
        for _ in range(self.tamano):
            if actual.valor == valor:
                if anterior is None:  # Es cabeza
                    self.cabeza = actual.siguiente
                    if self.circular and self.doble:
                        self.cola.siguiente = self.cabeza
                        self.cabeza.anterior = self.cola
                else:
                    anterior.siguiente = actual.siguiente
                    if self.doble and actual.siguiente:
                        actual.siguiente.anterior = anterior
                
                if actual == self.cola:
                    self.cola = anterior
                    if self.circular and anterior:
                        anterior.siguiente = self.cabeza
                        if self.doble:
                            self.cabeza.anterior = anterior
                
                self.tamano -= 1
                return True
            
            anterior = actual
            actual = actual.siguiente
        
        return False
    
    def contar_nodos(self):
        """Retorna número de nodos"""
        return self.tamano
    
    def buscar_nodo(self, valor):
        """Busca nodo por valor"""
        actual = self.cabeza
        for i in range(self.tamano):
            if actual.valor == valor:
                return {"pos": i, "valor": actual.valor}
            actual = actual.siguiente
        return None
    
    # ========== FUNCIONES DE VISUALIZACIÓN ==========
    
    def imprimir_valor_lista(self):
        """Imprime solo valores"""
        if self.esta_vacia():
            print("Lista vacía")
            return
        
        actual = self.cabeza
        for _ in range(self.tamano):
            print(actual.valor, end=" → " if not self.circular or _ < self.tamano-1 else " ⟲ ")
            actual = actual.siguiente
        print("FIN" if not self.circular else "")
    
    def imprimir_lista_completa(self):
        """Imprime todos los campos"""
        actual = self.cabeza
        print(f"\nLista {self.tipo} ({self.tamano} nodos):")
        for i in range(self.tamano):
            print(f"Pos {i}: Valor={actual.valor}", end="")
            print(f" | Siguiente={actual.siguiente.valor if actual.siguiente else 'None'}", end="")
            if self.doble:
                print(f" | Anterior={actual.anterior.valor if actual.anterior else 'None'}", end="")
            print()
            actual = actual.siguiente
    
    def imprimir_reves(self):
        """Imprime en reverso (solo listas dobles)"""
        if not self.doble or self.esta_vacia():
            print("No soportado")
            return
        
        actual = self.cola
        for _ in range(self.tamano):
            print(actual.valor, end=" ← " if _ < self.tamano-1 else "")
            actual = actual.anterior
        print()
    
    def copiar_lista(self):
        """Guarda lista en archivo"""
        try:
            with open(f"lista_{self.tipo}.txt", "w") as f:
                f.write(f"Lista {self.tipo}\n")
                f.write(f"Nodos: {self.tamano}\n")
                actual = self.cabeza
                for i in range(self.tamano):
                    f.write(f"Nodo {i}: {actual.valor}\n")
                    actual = actual.siguiente
            print(f"Guardado en lista_{self.tipo}.txt")
        except:
            print("Error al guardar")
    
    # ========== FUNCIÓN EXTRA ==========
    
    def ordenar_lista(self):
        """Ordena lista (burbuja optimizado)"""
        if self.tamano < 2:
            return
        
        for i in range(self.tamano - 1):
            actual = self.cabeza
            for j in range(self.tamano - i - 1):
                if actual.valor > actual.siguiente.valor:
                    # Intercambiar valores
                    actual.valor, actual.siguiente.valor = actual.siguiente.valor, actual.valor
                actual = actual.siguiente
        print("Lista ordenada")
    
    # ========== UTILIDADES ==========
    
    def esta_vacia(self):
        return self.tamano == 0
    
    def __str__(self):
        if self.esta_vacia():
            return "[]"
        
        result = []
        actual = self.cabeza
        for _ in range(self.tamano):
            result.append(str(actual.valor))
            actual = actual.siguiente
        
        separador = " ↔ " if self.doble else " → "
        return separador.join(result) + (" ⟲" if self.circular else "")

# ========== INTERFAZ SIMPLIFICADA ==========

def main():
    print("SISTEMA DE LISTAS OPTIMIZADO")
    print("1. Simple    2. Doble    3. Circular    4. Circular Doble")
    
    try:
        opcion = int(input("Seleccione tipo: "))
        if opcion not in range(1, 5):
            raise ValueError
        
        lista = Lista(opcion)
        print(f"\nLista {lista.tipo} creada\n")
        
        while True:
            print("\n" + "="*40)
            print("1. Insertar inicio   2. Insertar final")
            print("3. Insertar posición 4. Eliminar")
            print("5. Buscar            6. Contar")
            print("7. Ver lista         8. Ver completo")
            print("9. Reversa          10. Guardar")
            print("11. Ordenar         12. Salir")
            print("="*40)
            
            accion = int(input("Acción: "))
            
            if accion == 12:
                break
            elif accion == 1:
                lista.insertar_inicio(int(input("Valor: ")))
            elif accion == 2:
                if lista.esta_vacia():
                    print("Lista vacía, inserte al inicio primero")
                else:
                    lista.insertar_final(int(input("Valor: ")))
            elif accion == 3:
                valor = int(input("Valor: "))
                pos = int(input(f"Posición (0-{lista.tamano}): "))
                lista.insertar_nodo(valor, pos)
            elif accion == 4:
                if lista.eliminar_nodo(int(input("Valor a eliminar: "))):
                    print("Eliminado")
                else:
                    print("No encontrado")
            elif accion == 5:
                resultado = lista.buscar_nodo(int(input("Buscar: ")))
                print(f"Encontrado en posición {resultado['pos']}" if resultado else "No encontrado")
            elif accion == 6:
                print(f"Nodos: {lista.contar_nodos()}")
            elif accion == 7:
                print("Lista:", lista)
            elif accion == 8:
                lista.imprimir_lista_completa()
            elif accion == 9:
                lista.imprimir_reves()
            elif accion == 10:
                lista.copiar_lista()
            elif accion == 11:
                lista.ordenar_lista()
            
    except ValueError:
        print("Entrada inválida")
    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    main()